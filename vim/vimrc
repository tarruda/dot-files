" Title: vimrc
" Author: Thiago de Arruda (github.com/tarruda)
" Description:
"   This file initializes my vim customizations/addons.  It was tested on vim
"   7.3 compiled with most features.  A lot here was taken from this vimrc:
"   https://bitbucket.org/sjl/dotfiles/src/tip/vim/vimrc

" Basic initialization {{{
"
set nocompatible

if !exists('g:vimrc_done_basic_init')

  let g:is_windows = has('win32') || has('win64')
  " Little hack to set the $MYVIMRC from the $VIMINIT in the case it was used to 
  " initialize vim.
  let s:default_vimrc = 1
  if empty($MYVIMRC)
    let $MYVIMRC = substitute($VIMINIT, "^source ", "", "g")
    let s:default_vimrc = 0
  endif
  " Extract the directory from $MYVIMRC
  let g:rc_dir = strpart($MYVIMRC, 0, strridx($MYVIMRC, (g:is_windows ? '\' : '/')))
  if s:default_vimrc
    " Set .vim as the rc_dir
    let g:rc_dir = g:rc_dir.'/.vim'
  endif
  let $RCDIR = g:rc_dir
  let g:plugins_dir = g:rc_dir.'/plugged'
  let g:vim_plug_dir = g:plugins_dir.'/vim-plug'
  let &runtimepath = g:rc_dir.','.g:vim_plug_dir.','.$VIMRUNTIME
  if has('nvim')
    set unnamedclip
  endif
  let g:has_python = has('python')
endif

" }}}
" Global settings {{{
"
let mapleader = ","
set backspace=indent,eol,start " backspace over everything in insert mode
set nobackup " no need for backup files(use undo files instead)
set undofile " create '.<FILENAME>.un~' for persiting undo history
set dir=.,/tmp " swap files storage, first try in the cwd then in /tmp
set undodir=. " undo files storage, only allow the same directory
set history=500 " 500 lines of command-line history
set ruler " display cursor position at bottom
set mouse=a " enable terminal mouse extensions
if &term =~ 'tmux' " requires my custom terminfo file
  set ttymouse=xterm2 " integrate mouse extensions with tmux
  set ttyfast " normally this is only set for certain known terminals
endi
set noerrorbells visualbell t_vb= " disable annoying terminal sounds
set encoding=utf-8 " universal text encoding, compatible with ascii
set list
if has('win32unix') && ! has('gui_running') " cygwin on terminal
  " cygwin's urxvt seems to have trouble displaying some unicode chars
  set listchars=tab:‚ñ∏\ ,
else
  set listchars=tab:‚ñ∏\ ,extends:‚ùØ,precedes:‚ùÆ " ,eol:¬¨
  set showbreak=‚Ü™
  set fillchars=diff:‚£ø,vert:‚îÇ
endif
set showcmd " display incomplete commands
set completeopt=menu,menuone,longest " disable preview scratch window
set complete=.,w,b,u,t " h: 'complete'
set pumheight=15 " limit completion menu height
set nonumber " don't display line numbers on the left
set relativenumber " shows relative line numbers for easy motions
set splitbelow " put horizontal splits below 
set splitright " put vertical splits to the right
set expandtab " expand tabs into spaces
set softtabstop=2 " number of spaces used with tab/bs
set tabstop=2 " display tabs with the width of two spaces
set shiftwidth=2 " indent with two spaces 
set ignorecase " ignore case when searching
set smartcase " disable 'ignorecase' if search pattern has uppercase characters
set incsearch " highlight matches while typing search pattern
set hlsearch " highlight previous search matches
set showmatch " briefly jump to the matching bracket on insert
set matchtime=2 " time in decisecons to jump back from matching bracket 
set textwidth=80 " number of character allowed in a line
set wrap " automatically wrap text when 'textwidth' is reached
set foldmethod=indent " by default, fold using indentation
set nofoldenable " don't fold by default
set foldlevel=0 " if fold everything if 'foldenable' is set
set foldnestmax=10 " maximum fold depth
set synmaxcol=500 " maximum length to apply syntax highlighting
set timeout " enable timeout of key codes and mappings(the default)
set timeoutlen=3000 " big timeout for key sequences
set ttimeoutlen=10 " small timeout for key sequences since these will be normally scripted
set clipboard=
syntax on " enable syntax highlighting
filetype plugin indent on " enable file-specific plugins/settings
set backupskip=/tmp/*,/private/tmp/* " make it possible to use vim to edit crontab
augroup global_settings
  au!
  au VimResized * :wincmd = " resize windows when vim is resized 
  " return to the same line when file is reopened
  au BufReadPost *
        \ if line("'\"") > 0 && line("'\"") <= line("$") |
        \     execute 'normal! g`"zvzz' |
        \ endif
augroup END
" if available, store temporary files in shared memory
if isdirectory('/run/shm')
  let $TMPDIR = '/run/shm'
elseif isdirectory('/dev/shm')
  let $TMPDIR = '/dev/shm'
endif
" }}}
" Terminal keycode sequences {{{
:set <f1>=OP
if ! has('gui_running')
  " this is used to represent ctrl+tab in terminal vim
  :set <f20>=[34~
endif
if &term == 'tmux'
  :set <up>=[A
  :set <down>=[B
  :set <right>=[C
  :set <left>=[D
  " Prefix used by tmux to send 'special commands' to vim. I use this so there's
  " no possibility of tmux accidentally hitting my own mappings. Think of it as
  " a namespace used for tmux-related commands
  :set <f37>=tmux
elseif &term =~ 'rxvt-unicode' || &term =~ 'xterm'
  " with urxvt configured to use xterm control/alt sequences
  " this should normalize vim/gvim mappings
  :set <a-k>=k
  :set <a-j>=j
  :set <a-l>=l
  :set <a-h>=h
endif
" }}}
" Custom commands {{{
" Allows saving files which needs root permission with ':w!!'. This uses  one of
" the forms of the ':w' command, which instead of writing to a file, takes all
" lines in a range(or the whole buffer if not range is specified) and pipes as
" standard input for the command after '!'. In this case 'tee' will redirect its
" standard input(the entire buffer) to the file being edited(%)
cnoremap w!! w !sudo tee % >/dev/null
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.  Only define it when not
" defined already.
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis

command! -nargs=? -complete=help Help call OpenHelpInCurrentWindow(<q-args>)

command! -nargs=? -complete=customlist,ScratchPadComplete ScratchPad call OpenScratchPad(<q-args>)

" }}}
" Utility functions {{{

" Restore cursor position, window position, and last search after running a
" command.
" from: http://stackoverflow.com/questions/12374200/using-uncrustify-with-vim
function! Preserve(command)
  " Save the last search.
  let search = @/

  " Save the current cursor position.
  let cursor_position = getpos('.')

  " Save the current window position.
  normal! H
  let window_position = getpos('.')
  call setpos('.', cursor_position)

  " Execute the command.
  execute a:command

  " Restore the last search.
  let @/ = search

  " Restore the previous window position.
  call setpos('.', window_position)
  normal! zt

  " Restore the previous cursor position.
  call setpos('.', cursor_position)
endfunction

" Specify path to your Uncrustify configuration file.
let g:uncrustify_cfg_file_path =
    \ shellescape(fnamemodify('~/.uncrustify.cfg', ':p'))

" Don't forget to add Uncrustify executable to $PATH (on Unix) or 
" %PATH% (on Windows) for this command to work.
function! Uncrustify(language)
  call Preserve(':silent %!uncrustify'
      \ . ' -q '
      \ . ' -l ' . a:language
      \ . ' -c ' . g:uncrustify_cfg_file_path)
endfunction

function! OpenHelpInCurrentWindow(topic)
  view $VIMRUNTIME/doc/help.txt
  setl filetype=help
  setl buftype=help
  setl nomodifiable
  exe 'keepjumps help ' . a:topic
endfunction

" ScratchPad {{{
augroup scratchpad
  au!
  au BufNewFile,BufRead .scratchpads/scratchpad.* call ScratchPadLoad()
augroup END

function! ScratchPadSave()
  let ftype = matchstr(expand('%'), 'scratchpad\.\zs\(.\+\)$')
  if ftype == ''
    return
  endif
  write
endfunction

function! ScratchPadLoad()
  nnoremap <silent> <buffer> q :w<cr>:close<cr>
  setlocal bufhidden=hide buflisted noswapfile
endfunction

function! OpenScratchPad(ftype)
  if a:0 > 0
    let ftype = a:ftype
  else
    let pads = split(globpath('.scratchpads', 'scratchpad.*'), '\n')
    if len(pads) > 0
      let ftype = matchstr(pads[0], 'scratchpad\.\zs\(.\+\)$')
    else
      let ftype = expand('%:e')
    endif
  endif

  if ftype == ''
    echoerr 'Scratchpad need a filetype'
    return
  endif

  let scratchpad_name = '.scratchpads/scratchpad.' . ftype
  let scr_bufnum = bufnr(scratchpad_name)

  if scr_bufnum == -1
    " open the scratchpad
    exe "new " . scratchpad_name
    let dir = expand('%:p:h')
    if !isdirectory(dir)
      call mkdir(dir)
    endif
  else
    " Scratch buffer is already created. Check whether it is open
    " in one of the windows
    let scr_winnum = bufwinnr(scr_bufnum)
    if scr_winnum != -1
      " Jump to the window which has the scratchpad if we are not
      " already in that window
      if winnr() != scr_winnum
        exe scr_winnum . "wincmd w"
      endif
    else
      exe "split +buffer" . scr_bufnum
    endif
  endif
endfunction
" }}}

function! GetVisualSelection()
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - 2]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunction

if &term == 'tmux'
  " tranparent window/pane movement
  function! TmuxMove(direction)
    " Check if we are currently focusing on a edge window.
    " To achieve that,  move to/from the requested window and
    " see if the window number changed
    let oldw = winnr()
    silent! exe 'wincmd ' . a:direction
    let neww = winnr()
    silent! exe oldw . 'wincmd'
    if oldw == neww
      " The focused window is at an edge, so ask tmux to switch panes
      if a:direction == 'j'
        call system("tmux select-pane -D")
      elseif a:direction == 'k'
        call system("tmux select-pane -U")
      elseif a:direction == 'h'
        call system("tmux select-pane -L")
      elseif a:direction == 'l'
        call system("tmux select-pane -R")
      endif
    end
  endfunction
endif
" }}}
" Mappings {{{
function! Manpage()
  let word = expand('<cword>')
  enew!
  setl nomod nolist nonumber norelativenumber
  nnoremap q :bd!<cr>
  setf man
  exe 'r !man '.word
  normal gg
endfunction
nnoremap K :call Manpage()<cr>
" Quickly open/close quickfix and location list, based on
" github:Valloric/ListToogle
augroup quick_loc_list
  au! BufWinEnter quickfix nnoremap <silent> <buffer> q :cclose<cr>:lclose<cr>
augroup END
nnoremap <silent> <leader>q :botright copen 10<cr>
nnoremap <silent> <leader>l :botright lopen 10<cr>

nmap T @t
nnoremap <silent> <c-j> :m .+1<cr>==
nnoremap <silent> <c-k> :m .-2<cr>==
" Quickly open a scratchpad
nnoremap <leader>sp :ScratchPad<cr>
" Move selections
vnoremap <silent> <c-j> :m '>+1<cr>gv=gv
vnoremap <silent> <c-k> :m '<-2<cr>gv=gv
" Remap the help key
inoremap <f1> <esc>:Help 
nnoremap <f1> <esc>:Help 
vnoremap <f1> <esc>:Help 
" search/replace the word under the cursor
nnoremap <leader>z :let @z = expand("<cword>")<cr>q:i%s/\C\v<<esc>"zpa>//g<esc>hi
" Quickly toggle spell on/off
nnoremap <silent> <leader>s :set spell!<cr>
" Clear search highlight with ,c
nnoremap <silent> <leader>c :noh<cr>
" Capitalize the first word of every sentence in a selection and format it.
" Useful for quickly formatting comments. The capitalize part was taken from:
" http://societyserver.org/mbaehr/vim-tips--capitalize-the-first-word-of-every-sentence
vnoremap <silent> <leader>f :s/\v(\w)(\_[^.?!:;]*)/\u\1\2/g<cr>:noh<cr>gvgq
" quickly edit vimrc
nnoremap <leader>e :e $MYVIMRC<cr>
" quickly reload vimrc
nnoremap <leader>r :source $MYVIMRC<cr>:e<cr>
if &term == 'tmux'
  " tmux will handle the actual mappings so we just 
  nnoremap <silent> <f37>move-down :silent call TmuxMove('j')<cr>
  nnoremap <silent> <f37>move-up :silent call TmuxMove('k')<cr>
  nnoremap <silent> <f37>move-left :silent call TmuxMove('h')<cr>
  nnoremap <silent> <f37>move-right :silent call TmuxMove('l')<cr>
  inoremap <silent> <f37>move-down <esc>:silent call TmuxMove('j')<cr>
  inoremap <silent> <f37>move-up <esc>:silent call TmuxMove('k')<cr>
  inoremap <silent> <f37>move-left <esc>:silent call TmuxMove('h')<cr>
  inoremap <silent> <f37>move-right <esc>:silent call TmuxMove('l')<cr>
  vnoremap <silent> <f37>move-down <esc>:silent call TmuxMove('j')<cr>
  vnoremap <silent> <f37>move-up <esc>:silent call TmuxMove('k')<cr>
  vnoremap <silent> <f37>move-left <esc>:silent call TmuxMove('h')<cr>
  vnoremap <silent> <f37>move-right <esc>:silent call TmuxMove('l')<cr>
else
  nnoremap <silent> <a-j> :wincmd j<cr>
  nnoremap <silent> <a-k> :wincmd k<cr>
  nnoremap <silent> <a-h> :wincmd h<cr>
  nnoremap <silent> <a-l> :wincmd l<cr>
  nnoremap <silent> <a-down> :wincmd j<cr>
  nnoremap <silent> <a-up> :wincmd k<cr>
  nnoremap <silent> <a-left> :wincmd h<cr>
  nnoremap <silent> <a-right> :wincmd l<cr>
  inoremap <silent> <a-j> <esc>:wincmd j<cr>
  inoremap <silent> <a-k> <esc>:wincmd k<cr>
  inoremap <silent> <a-h> <esc>:wincmd h<cr>
  inoremap <silent> <a-l> <esc>:wincmd l<cr>
  inoremap <silent> <a-down> <esc>:wincmd j<cr>
  inoremap <silent> <a-up> <esc>:wincmd k<cr>
  inoremap <silent> <a-left> <esc>:wincmd h<cr>
  inoremap <silent> <a-right> <esc>:wincmd l<cr>
  vnoremap <silent> <a-j> <esc>:wincmd j<cr>
  vnoremap <silent> <a-k> <esc>:wincmd k<cr>
  vnoremap <silent> <a-h> <esc>:wincmd h<cr>
  vnoremap <silent> <a-l> <esc>:wincmd l<cr>
  vnoremap <silent> <a-down> <esc>:wincmd j<cr>
  vnoremap <silent> <a-up> <esc>:wincmd k<cr>
  vnoremap <silent> <a-left> <esc>:wincmd h<cr>
  vnoremap <silent> <a-right> <esc>:wincmd l<cr>
endif
" }}}
" Filetype settings {{{
augroup filetype_settings
  au!
  " Filetype detection {{{
  " my vimrc may not have the usual path
  au BufNewFile,BufRead $MYVIMRC setl filetype=vim
  au BufNewFile,BufRead *.vimp setl filetype=vim " vimperator files
  " tmux rc file
  au  BufNewFile,BufRead .tmux.conf,tmuxrc,site-tmuxrc setl filetype=tmux
  " html with mustaches
  au  BufNewFile,BufRead *.html.mustache,*.html.handlebars,*.html.hbs,*.html.hogan,*.html.hulk setl filetype=html.mustache
  " extra zsh files without extensions 
  au BufNewFile,BufRead $ZDOTDIR/functions/**/* setl filetype=zsh
  au BufNewFile,BufRead $ZDOTDIR/completion-functions/* setl filetype=zsh
  au BufNewFile,BufRead $ZDOTDIR/plugins/**/functions/* setl filetype=zsh
  " }}}
  " Coffeescript {{{
  au FileType coffee
        \   setl foldmethod=marker
        \ | setl foldenable
  " }}}
  " Html {{{
  au FileType html
        \   setl foldmethod=marker
        \ | setl foldenable
  " }}}
  " Vim {{{
  au FileType vim
        \   setl foldmethod=marker
        \ | setl foldenable
  " }}}
  " C/C++ {{{
  au FileType c,cpp
        \   nnoremap <buffer> <silent> <leader>ff :call Uncrustify('c')<cr>
        \ | setl commentstring=//%s
  " }}}
  " Moonscript {{{
  au FileType moon
        \   setl commentstring=--%s
  " }}}
  " Zsh/sh {{{
  au FileType sh,bash,zsh setl noexpandtab
  au FileType zsh 
        \   runtime! indent/sh.vim
        \ | setl foldmethod=marker
        \ | setl foldenable
  " \ | setl listchars=tab:\ \ ,eol:¬¨,extends:‚ùØ,precedes:‚ùÆ
  " }}}
  " Haskell {{{
  au FileType haskell
        \   setl softtabstop=4
        \ | setl shiftwidth=4
        \ | setl textwidth=75
        \ | nnoremap <buffer> <leader>h :Hoogle 

  " }}}
  " Nasm {{{
  au FileType nasm 
        \   setl softtabstop=4
        \ | setl shiftwidth=4 
        \ | setl textwidth=150
  " }}}
  " Python {{{
  au FileType python 
        \   setl softtabstop=4
        \ | setl shiftwidth=4 
        \ | setl textwidth=79
  command! DocTest !python -m doctest %
  " }}}
  " Muttrc {{{
  au FileType muttrc 
        \   setl foldmethod=marker
        \ | setl foldenable
  " }}}
  " Mail {{{
  au FileType mail 
        \   setl foldmethod=marker
        \ | setl foldenable
        \ | setl omnifunc=CompleteGoogleContact
  " }}}
  " Mail {{{
  au FileType man 
        \   setl foldmethod=indent
        \ | setl foldenable
        \ | setl foldnestmax=1
  " }}}
augroup END

" }}}
" Appearance {{{
"
if has('gui_running') " gvim
  colorscheme molokai
  if g:is_windows
    set guifont=Ubuntu\ Mono:h16
  elseif has('win32unix') " cygwin
    set guifont=Consolas\ 16
  else
    set guifont=Ubuntu\ Mono\ 16,Inconsolata\ 16,Monospace\ 14
  endif
  set guioptions=
else

  if &term =~ 'tmux' || &term =~ 'rxvt-unicode-256color'
        \ || &term =~ 'xterm-256color'
    colorscheme twilight-term256
  endif

  if &term =~ 'tmux' || &term =~ 'rxvt-unicode-256color'
        \ || &term =~ 'xterm-256color-italic'
    " for tmux, this will only work if the client terminal supports italic
    " escape sequences
    highlight Comment cterm=italic
  endif

endif
" }}}
" Addons {{{
function! LoadAddons() 
  " Install vim-plug if not available
  if !isdirectory(g:vim_plug_dir)
    call mkdir(g:vim_plug_dir, 'p')
  endif
  if !isdirectory(g:vim_plug_dir.'/autoload')
    execute '!git clone git://github.com/junegunn/vim-plug '
          \ shellescape(g:vim_plug_dir.'/autoload', 1)
  endif

  call plug#begin(g:plugins_dir)
  " Vim-Dispatch {{{ "
  Plug 'tpope/vim-dispatch'
  " }}}
  " Slimux {{{
  if $TMUX != ''
    Plug 'epeli/slimux'
    nnoremap <silent> <f5> :SlimuxSendKeysLast<cr>
    nnoremap <silent> <f6> :SlimuxREPLSendLine<cr>
    inoremap <silent> <f6> <esc>:SlimuxREPLSendLine<cr>i
    vnoremap <silent> <f6> :SlimuxREPLSendSelection<cr>
    nnoremap <silent> <f7> ggvG$:SlimuxREPLSendSelection<cr>
  endif
  " }}}
  " Vimproc {{{
  Plug 'Shougo/vimproc.vim', {'do': 'make -f make_unix.mak'}
  " }}}
  " Unite {{{
  Plug 'Shougo/Unite.vim'
  Plug 'Shougo/neomru.vim'
  nnoremap <c-u> :Unite -start-insert -auto-resize file file_rec/async buffer file_mru<cr>
  " }}}
  " CtrlP {{{
  Plug 'kien/ctrlp.vim'
  set wildignore+=*.o,*.so,*.dll,*.exe,*.bak,*.swp,*.class,*.pyc,*.pyd,*.pyo,*~
  set wildignore+=*.zip,*.tgz,*.gz,*.bz2,*.lz,*.rar,*.7z,*.jar
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/](\.(git|hg|svn|bzr)|node_modules)$',
        \ }
  let g:ctrlp_extensions = ['tag']
  let g:ctrlp_cmd = 'Ctrlp'
  fun! s:search()
    SourceLocalVimrcOnce
    CtrlP
  endf
  command! Ctrlp call s:search()
  nnoremap <silent> <leader>p :CtrlPTag<CR>
  " }}}
  " Syntastic {{{
  let g:syntastic_error_symbol = '‚úó'
  let g:syntastic_warning_symbol = '‚ö†'
  let g:syntastic_always_populate_loc_list = 1
  let g:syntastic_coffee_checkers=['coffee']
  let g:syntastic_haskell_checkers=['ghc_mod', 'hlint']
  let g:syntastic_python_checkers = ['flake8']
  let g:syntastic_scala_checkers = []
  let g:syntastic_ignore_files=['\.scratchpads/scratchpad\.\.*']
  Plug 'scrooloose/syntastic'
  " }}}
  " Lua {{{
  Plug 'leafo/moonscript-vim'
  " }}}
  " UltiSnips {{{
  if g:has_python
    let g:UltiSnipsEditSplit = 'normal'
    let g:UltiSnipsSnippetsDir = g:rc_dir . '/UltiSnips'
    let g:UltiSnipsExpandTrigger="<c-j>"
    let g:UltiSnipsJumpForwardTrigger="<c-j>"
    let g:UltiSnipsJumpBackwardTrigger="<c-k>"
    let g:UltiSnipsListSnippets="<c-tab>"
    Plug 'SirVer/ultisnips'
    Plug 'honza/vim-snippets'
  endif
  " }}}
  " YouCompleteMe {{{
  if g:has_python
    " let g:ycm_path_to_python_interpreter = s:cpython_path
    let g:ycm_auto_trigger = 1
    Plug 'Valloric/YouCompleteMe'
    au FileType c,cpp nnoremap <buffer> <c-]> :YcmCompleter GoToDefinitionElseDeclaration<CR>
  endif
  " }}}
  " NERDTree {{{
  Plug 'scrooloose/nerdtree'
  " close VIM if NERDTree is the only buffer left
  autocmd BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif
  " toggle NERDTree
  nnoremap <silent> <F2> :NERDTreeToggle<CR>
  " }}}
  " Gundo {{{
  if g:has_python
    Plug 'sjl/gundo.vim'
    nnoremap <leader>u :GundoToggle<cr>
  endif
  " }}}
  " Typescript-vim {{{
  Plug 'leafgarland/typescript-vim'
  setl textwidth=80
  setl shiftwidth=2
  setl expandtab
  " }}}
  " Haskell {{{
  let g:haskell_autotags = 1
  let g:hoogle_search_jump_back = 0
  let g:hoogle_search_count = 30
  let g:haskell_tags_generator = 'fast-tags'
  if g:has_python
    Plug 'dag/vim2hs'
  endif
  Plug 'eagletmt/ghcmod-vim'
  Plug 'Twinside/vim-hoogle'

  " }}}
  " Project-local vimrc {{{
  Plug 'MarcWeber/vim-addon-local-vimrc'
  let g:local_vimrc = {
        \ 'names': ['.lvimrc'],
        \ 'hash_fun': 'LVRHashOfFile'
        \ }
  " }}}
  " gnupg {{{
  let g:GPGPreferSymmetric = 1
  Plug 'jamessan/vim-gnupg'
  " }}}
  " Fugitive {{{
  nnoremap <leader>gs :Gstatus<cr>
  nnoremap <leader>gd :Gdiff<cr>
  nnoremap <leader>gb :Gblame<cr>
  nnoremap <leader>gw :Gwrite
  nnoremap <leader>gr :Gread
  nnoremap <leader>dp :diffput<cr>:diffupdate<cr>
  vnoremap <leader>dp :diffput<cr>:diffupdate<cr>
  nnoremap <leader>dg :diffget<cr>:diffupdate<cr>
  vnoremap <leader>dg :diffget<cr>:diffupdate<cr>
  Plug 'tpope/vim-fugitive'
  " }}}
  " Other {{{
  Plug 'Shougo/vinarise.vim'
  Plug 'google/vim-ft.vroom'
  Plug 'fatih/vim-go'
  Plug 'wting/rust.vim'
  Plug 'Raimondi/delimitMate' " autoclose brackets,quotes...
  Plug 'tpope/vim-tbone'
  Plug 'tpope/vim-unimpaired'
  Plug 'plasticboy/vim-markdown'
  Plug 'tpope/vim-repeat'
  Plug 'tpope/vim-surround'
  Plug 'tpope/vim-commentary'
  Plug 'juvenn/mustache.vim'
  Plug 'pangloss/vim-javascript'
  Plug 'kchmck/vim-coffee-script'
  Plug 'digitaltoad/vim-jade'
  Plug 'kelan/gyp.vim'
  Plug 'groenewege/vim-less'
  Plug 'danro/rename.vim'
  Plug 'mattn/webapi-vim'
  Plug 'mattn/gist-vim'
  Plug 'godlygeek/csapprox'
  Plug 'godlygeek/tabular'
  Plug 'rking/ag.vim'
  Plug 'PProvost/vim-ps1'
  Plug 'alunny/pegjs-vim'
  Plug 'vim-scripts/Decho'
  Plug 'Valloric/python-indent'
  Plug 'vim-scripts/DrawIt'
  " }}}
  call plug#end()

  " load 'after' directory
  let &runtimepath = &runtimepath.','.g:rc_dir.'/after'
  " }}} 
  let g:vimrc_done_basic_init = 1
endfunction
if !exists('g:vimrc_done_basic_init') && !exists('g:disable_addons')
  call LoadAddons()
endif
" }}}
